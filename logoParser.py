# Generated from logo.g4 by ANTLR 4.11.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,17,138,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,1,0,1,0,1,0,1,1,1,1,1,1,4,1,51,8,1,11,1,12,1,52,1,
        2,1,2,5,2,57,8,2,10,2,12,2,60,9,2,1,3,1,3,1,3,1,3,1,3,1,3,1,4,5,
        4,69,8,4,10,4,12,4,72,9,4,1,5,1,5,1,5,3,5,77,8,5,1,6,5,6,80,8,6,
        10,6,12,6,83,9,6,1,7,1,7,3,7,87,8,7,1,8,1,8,5,8,91,8,8,10,8,12,8,
        94,9,8,1,9,1,9,1,10,1,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,
        1,11,1,11,3,11,110,8,11,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,
        1,14,1,15,1,15,1,15,1,16,1,16,1,17,1,17,1,18,1,18,1,18,1,18,1,19,
        1,19,1,20,1,20,1,21,1,21,1,21,0,0,22,0,2,4,6,8,10,12,14,16,18,20,
        22,24,26,28,30,32,34,36,38,40,42,0,0,133,0,44,1,0,0,0,2,50,1,0,0,
        0,4,54,1,0,0,0,6,61,1,0,0,0,8,70,1,0,0,0,10,76,1,0,0,0,12,81,1,0,
        0,0,14,86,1,0,0,0,16,88,1,0,0,0,18,95,1,0,0,0,20,97,1,0,0,0,22,109,
        1,0,0,0,24,111,1,0,0,0,26,114,1,0,0,0,28,117,1,0,0,0,30,120,1,0,
        0,0,32,123,1,0,0,0,34,125,1,0,0,0,36,127,1,0,0,0,38,131,1,0,0,0,
        40,133,1,0,0,0,42,135,1,0,0,0,44,45,3,2,1,0,45,46,5,0,0,1,46,1,1,
        0,0,0,47,51,3,20,10,0,48,51,3,6,3,0,49,51,3,4,2,0,50,47,1,0,0,0,
        50,48,1,0,0,0,50,49,1,0,0,0,51,52,1,0,0,0,52,50,1,0,0,0,52,53,1,
        0,0,0,53,3,1,0,0,0,54,58,5,13,0,0,55,57,5,14,0,0,56,55,1,0,0,0,57,
        60,1,0,0,0,58,56,1,0,0,0,58,59,1,0,0,0,59,5,1,0,0,0,60,58,1,0,0,
        0,61,62,5,11,0,0,62,63,5,13,0,0,63,64,3,8,4,0,64,65,3,12,6,0,65,
        66,5,12,0,0,66,7,1,0,0,0,67,69,3,10,5,0,68,67,1,0,0,0,69,72,1,0,
        0,0,70,68,1,0,0,0,70,71,1,0,0,0,71,9,1,0,0,0,72,70,1,0,0,0,73,74,
        5,17,0,0,74,77,5,13,0,0,75,77,5,14,0,0,76,73,1,0,0,0,76,75,1,0,0,
        0,77,11,1,0,0,0,78,80,3,14,7,0,79,78,1,0,0,0,80,83,1,0,0,0,81,79,
        1,0,0,0,81,82,1,0,0,0,82,13,1,0,0,0,83,81,1,0,0,0,84,87,3,18,9,0,
        85,87,3,16,8,0,86,84,1,0,0,0,86,85,1,0,0,0,87,15,1,0,0,0,88,92,5,
        13,0,0,89,91,3,10,5,0,90,89,1,0,0,0,91,94,1,0,0,0,92,90,1,0,0,0,
        92,93,1,0,0,0,93,17,1,0,0,0,94,92,1,0,0,0,95,96,3,22,11,0,96,19,
        1,0,0,0,97,98,3,22,11,0,98,21,1,0,0,0,99,110,3,24,12,0,100,110,3,
        26,13,0,101,110,3,28,14,0,102,110,3,30,15,0,103,110,3,32,16,0,104,
        110,3,34,17,0,105,110,3,38,19,0,106,110,3,36,18,0,107,110,3,40,20,
        0,108,110,3,42,21,0,109,99,1,0,0,0,109,100,1,0,0,0,109,101,1,0,0,
        0,109,102,1,0,0,0,109,103,1,0,0,0,109,104,1,0,0,0,109,105,1,0,0,
        0,109,106,1,0,0,0,109,107,1,0,0,0,109,108,1,0,0,0,110,23,1,0,0,0,
        111,112,5,2,0,0,112,113,3,10,5,0,113,25,1,0,0,0,114,115,5,3,0,0,
        115,116,3,10,5,0,116,27,1,0,0,0,117,118,5,5,0,0,118,119,3,10,5,0,
        119,29,1,0,0,0,120,121,5,4,0,0,121,122,3,10,5,0,122,31,1,0,0,0,123,
        124,5,6,0,0,124,33,1,0,0,0,125,126,5,7,0,0,126,35,1,0,0,0,127,128,
        5,10,0,0,128,129,3,10,5,0,129,130,3,10,5,0,130,37,1,0,0,0,131,132,
        5,1,0,0,132,39,1,0,0,0,133,134,5,9,0,0,134,41,1,0,0,0,135,136,5,
        8,0,0,136,43,1,0,0,0,9,50,52,58,70,76,81,86,92,109
    ]

class logoParser ( Parser ):

    grammarFileName = "logo.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "','", "<INVALID>", 
                     "':'" ]

    symbolicNames = [ "<INVALID>", "RANDOM", "FORWARD", "BACKWARD", "RIGHT", 
                      "LEFT", "PENUP", "PENDOWN", "CLEAR_SCREEN", "WIPE_CLEAN", 
                      "SET_XY", "TO", "END", "IDENTIFIER", "SCIENTIFIC_NUMBER", 
                      "COMMA", "WS", "COLON" ]

    RULE_file_ = 0
    RULE_program = 1
    RULE_invoke_function = 2
    RULE_function_declaration = 3
    RULE_function_args_declaration = 4
    RULE_function_arg = 5
    RULE_function_body = 6
    RULE_function_body_statement = 7
    RULE_function_declare_invoke = 8
    RULE_command_declare_invoke = 9
    RULE_invoke_command = 10
    RULE_command = 11
    RULE_forward = 12
    RULE_backward = 13
    RULE_left = 14
    RULE_right = 15
    RULE_penup = 16
    RULE_pendown = 17
    RULE_setxy = 18
    RULE_random = 19
    RULE_wipe_clean = 20
    RULE_clear_screen = 21

    ruleNames =  [ "file_", "program", "invoke_function", "function_declaration", 
                   "function_args_declaration", "function_arg", "function_body", 
                   "function_body_statement", "function_declare_invoke", 
                   "command_declare_invoke", "invoke_command", "command", 
                   "forward", "backward", "left", "right", "penup", "pendown", 
                   "setxy", "random", "wipe_clean", "clear_screen" ]

    EOF = Token.EOF
    RANDOM=1
    FORWARD=2
    BACKWARD=3
    RIGHT=4
    LEFT=5
    PENUP=6
    PENDOWN=7
    CLEAR_SCREEN=8
    WIPE_CLEAN=9
    SET_XY=10
    TO=11
    END=12
    IDENTIFIER=13
    SCIENTIFIC_NUMBER=14
    COMMA=15
    WS=16
    COLON=17

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.11.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class File_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def program(self):
            return self.getTypedRuleContext(logoParser.ProgramContext,0)


        def EOF(self):
            return self.getToken(logoParser.EOF, 0)

        def getRuleIndex(self):
            return logoParser.RULE_file_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_" ):
                listener.enterFile_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_" ):
                listener.exitFile_(self)




    def file_(self):

        localctx = logoParser.File_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_file_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 44
            self.program()
            self.state = 45
            self.match(logoParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def invoke_command(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(logoParser.Invoke_commandContext)
            else:
                return self.getTypedRuleContext(logoParser.Invoke_commandContext,i)


        def function_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(logoParser.Function_declarationContext)
            else:
                return self.getTypedRuleContext(logoParser.Function_declarationContext,i)


        def invoke_function(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(logoParser.Invoke_functionContext)
            else:
                return self.getTypedRuleContext(logoParser.Invoke_functionContext,i)


        def getRuleIndex(self):
            return logoParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = logoParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 50
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
                    self.state = 47
                    self.invoke_command()
                    pass
                elif token in [11]:
                    self.state = 48
                    self.function_declaration()
                    pass
                elif token in [13]:
                    self.state = 49
                    self.invoke_function()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 52 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & 12286) != 0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Invoke_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(logoParser.IDENTIFIER, 0)

        def SCIENTIFIC_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(logoParser.SCIENTIFIC_NUMBER)
            else:
                return self.getToken(logoParser.SCIENTIFIC_NUMBER, i)

        def getRuleIndex(self):
            return logoParser.RULE_invoke_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInvoke_function" ):
                listener.enterInvoke_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInvoke_function" ):
                listener.exitInvoke_function(self)




    def invoke_function(self):

        localctx = logoParser.Invoke_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_invoke_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.match(logoParser.IDENTIFIER)

            self.state = 58
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==14:
                self.state = 55
                self.match(logoParser.SCIENTIFIC_NUMBER)
                self.state = 60
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TO(self):
            return self.getToken(logoParser.TO, 0)

        def IDENTIFIER(self):
            return self.getToken(logoParser.IDENTIFIER, 0)

        def function_args_declaration(self):
            return self.getTypedRuleContext(logoParser.Function_args_declarationContext,0)


        def function_body(self):
            return self.getTypedRuleContext(logoParser.Function_bodyContext,0)


        def END(self):
            return self.getToken(logoParser.END, 0)

        def getRuleIndex(self):
            return logoParser.RULE_function_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_declaration" ):
                listener.enterFunction_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_declaration" ):
                listener.exitFunction_declaration(self)




    def function_declaration(self):

        localctx = logoParser.Function_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_function_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.match(logoParser.TO)
            self.state = 62
            self.match(logoParser.IDENTIFIER)
            self.state = 63
            self.function_args_declaration()
            self.state = 64
            self.function_body()
            self.state = 65
            self.match(logoParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_args_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(logoParser.Function_argContext)
            else:
                return self.getTypedRuleContext(logoParser.Function_argContext,i)


        def getRuleIndex(self):
            return logoParser.RULE_function_args_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_args_declaration" ):
                listener.enterFunction_args_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_args_declaration" ):
                listener.exitFunction_args_declaration(self)




    def function_args_declaration(self):

        localctx = logoParser.Function_args_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_function_args_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 70
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==14 or _la==17:
                self.state = 67
                self.function_arg()
                self.state = 72
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_argContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(logoParser.COLON, 0)

        def IDENTIFIER(self):
            return self.getToken(logoParser.IDENTIFIER, 0)

        def SCIENTIFIC_NUMBER(self):
            return self.getToken(logoParser.SCIENTIFIC_NUMBER, 0)

        def getRuleIndex(self):
            return logoParser.RULE_function_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_arg" ):
                listener.enterFunction_arg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_arg" ):
                listener.exitFunction_arg(self)




    def function_arg(self):

        localctx = logoParser.Function_argContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_function_arg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 76
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [17]:
                self.state = 73
                self.match(logoParser.COLON)
                self.state = 74
                self.match(logoParser.IDENTIFIER)
                pass
            elif token in [14]:
                self.state = 75
                self.match(logoParser.SCIENTIFIC_NUMBER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_bodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_body_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(logoParser.Function_body_statementContext)
            else:
                return self.getTypedRuleContext(logoParser.Function_body_statementContext,i)


        def getRuleIndex(self):
            return logoParser.RULE_function_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_body" ):
                listener.enterFunction_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_body" ):
                listener.exitFunction_body(self)




    def function_body(self):

        localctx = logoParser.Function_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_function_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & 10238) != 0:
                self.state = 78
                self.function_body_statement()
                self.state = 83
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_body_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def command_declare_invoke(self):
            return self.getTypedRuleContext(logoParser.Command_declare_invokeContext,0)


        def function_declare_invoke(self):
            return self.getTypedRuleContext(logoParser.Function_declare_invokeContext,0)


        def getRuleIndex(self):
            return logoParser.RULE_function_body_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_body_statement" ):
                listener.enterFunction_body_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_body_statement" ):
                listener.exitFunction_body_statement(self)




    def function_body_statement(self):

        localctx = logoParser.Function_body_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_function_body_statement)
        try:
            self.state = 86
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
                self.enterOuterAlt(localctx, 1)
                self.state = 84
                self.command_declare_invoke()
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 2)
                self.state = 85
                self.function_declare_invoke()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_declare_invokeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(logoParser.IDENTIFIER, 0)

        def function_arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(logoParser.Function_argContext)
            else:
                return self.getTypedRuleContext(logoParser.Function_argContext,i)


        def getRuleIndex(self):
            return logoParser.RULE_function_declare_invoke

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_declare_invoke" ):
                listener.enterFunction_declare_invoke(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_declare_invoke" ):
                listener.exitFunction_declare_invoke(self)




    def function_declare_invoke(self):

        localctx = logoParser.Function_declare_invokeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_function_declare_invoke)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self.match(logoParser.IDENTIFIER)
            self.state = 92
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==14 or _la==17:
                self.state = 89
                self.function_arg()
                self.state = 94
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Command_declare_invokeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def command(self):
            return self.getTypedRuleContext(logoParser.CommandContext,0)


        def getRuleIndex(self):
            return logoParser.RULE_command_declare_invoke

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommand_declare_invoke" ):
                listener.enterCommand_declare_invoke(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommand_declare_invoke" ):
                listener.exitCommand_declare_invoke(self)




    def command_declare_invoke(self):

        localctx = logoParser.Command_declare_invokeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_command_declare_invoke)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self.command()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Invoke_commandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def command(self):
            return self.getTypedRuleContext(logoParser.CommandContext,0)


        def getRuleIndex(self):
            return logoParser.RULE_invoke_command

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInvoke_command" ):
                listener.enterInvoke_command(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInvoke_command" ):
                listener.exitInvoke_command(self)




    def invoke_command(self):

        localctx = logoParser.Invoke_commandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_invoke_command)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self.command()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forward(self):
            return self.getTypedRuleContext(logoParser.ForwardContext,0)


        def backward(self):
            return self.getTypedRuleContext(logoParser.BackwardContext,0)


        def left(self):
            return self.getTypedRuleContext(logoParser.LeftContext,0)


        def right(self):
            return self.getTypedRuleContext(logoParser.RightContext,0)


        def penup(self):
            return self.getTypedRuleContext(logoParser.PenupContext,0)


        def pendown(self):
            return self.getTypedRuleContext(logoParser.PendownContext,0)


        def random(self):
            return self.getTypedRuleContext(logoParser.RandomContext,0)


        def setxy(self):
            return self.getTypedRuleContext(logoParser.SetxyContext,0)


        def wipe_clean(self):
            return self.getTypedRuleContext(logoParser.Wipe_cleanContext,0)


        def clear_screen(self):
            return self.getTypedRuleContext(logoParser.Clear_screenContext,0)


        def getRuleIndex(self):
            return logoParser.RULE_command

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommand" ):
                listener.enterCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommand" ):
                listener.exitCommand(self)




    def command(self):

        localctx = logoParser.CommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_command)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2]:
                self.state = 99
                self.forward()
                pass
            elif token in [3]:
                self.state = 100
                self.backward()
                pass
            elif token in [5]:
                self.state = 101
                self.left()
                pass
            elif token in [4]:
                self.state = 102
                self.right()
                pass
            elif token in [6]:
                self.state = 103
                self.penup()
                pass
            elif token in [7]:
                self.state = 104
                self.pendown()
                pass
            elif token in [1]:
                self.state = 105
                self.random()
                pass
            elif token in [10]:
                self.state = 106
                self.setxy()
                pass
            elif token in [9]:
                self.state = 107
                self.wipe_clean()
                pass
            elif token in [8]:
                self.state = 108
                self.clear_screen()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForwardContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORWARD(self):
            return self.getToken(logoParser.FORWARD, 0)

        def function_arg(self):
            return self.getTypedRuleContext(logoParser.Function_argContext,0)


        def getRuleIndex(self):
            return logoParser.RULE_forward

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForward" ):
                listener.enterForward(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForward" ):
                listener.exitForward(self)




    def forward(self):

        localctx = logoParser.ForwardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_forward)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.match(logoParser.FORWARD)
            self.state = 112
            self.function_arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BackwardContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BACKWARD(self):
            return self.getToken(logoParser.BACKWARD, 0)

        def function_arg(self):
            return self.getTypedRuleContext(logoParser.Function_argContext,0)


        def getRuleIndex(self):
            return logoParser.RULE_backward

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBackward" ):
                listener.enterBackward(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBackward" ):
                listener.exitBackward(self)




    def backward(self):

        localctx = logoParser.BackwardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_backward)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.match(logoParser.BACKWARD)
            self.state = 115
            self.function_arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LeftContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT(self):
            return self.getToken(logoParser.LEFT, 0)

        def function_arg(self):
            return self.getTypedRuleContext(logoParser.Function_argContext,0)


        def getRuleIndex(self):
            return logoParser.RULE_left

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeft" ):
                listener.enterLeft(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeft" ):
                listener.exitLeft(self)




    def left(self):

        localctx = logoParser.LeftContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_left)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(logoParser.LEFT)
            self.state = 118
            self.function_arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RIGHT(self):
            return self.getToken(logoParser.RIGHT, 0)

        def function_arg(self):
            return self.getTypedRuleContext(logoParser.Function_argContext,0)


        def getRuleIndex(self):
            return logoParser.RULE_right

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRight" ):
                listener.enterRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRight" ):
                listener.exitRight(self)




    def right(self):

        localctx = logoParser.RightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_right)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self.match(logoParser.RIGHT)
            self.state = 121
            self.function_arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PenupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PENUP(self):
            return self.getToken(logoParser.PENUP, 0)

        def getRuleIndex(self):
            return logoParser.RULE_penup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenup" ):
                listener.enterPenup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenup" ):
                listener.exitPenup(self)




    def penup(self):

        localctx = logoParser.PenupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_penup)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(logoParser.PENUP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PendownContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PENDOWN(self):
            return self.getToken(logoParser.PENDOWN, 0)

        def getRuleIndex(self):
            return logoParser.RULE_pendown

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPendown" ):
                listener.enterPendown(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPendown" ):
                listener.exitPendown(self)




    def pendown(self):

        localctx = logoParser.PendownContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_pendown)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(logoParser.PENDOWN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetxyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET_XY(self):
            return self.getToken(logoParser.SET_XY, 0)

        def function_arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(logoParser.Function_argContext)
            else:
                return self.getTypedRuleContext(logoParser.Function_argContext,i)


        def getRuleIndex(self):
            return logoParser.RULE_setxy

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetxy" ):
                listener.enterSetxy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetxy" ):
                listener.exitSetxy(self)




    def setxy(self):

        localctx = logoParser.SetxyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_setxy)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.match(logoParser.SET_XY)
            self.state = 128
            self.function_arg()
            self.state = 129
            self.function_arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RandomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANDOM(self):
            return self.getToken(logoParser.RANDOM, 0)

        def getRuleIndex(self):
            return logoParser.RULE_random

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRandom" ):
                listener.enterRandom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRandom" ):
                listener.exitRandom(self)




    def random(self):

        localctx = logoParser.RandomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_random)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(logoParser.RANDOM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Wipe_cleanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WIPE_CLEAN(self):
            return self.getToken(logoParser.WIPE_CLEAN, 0)

        def getRuleIndex(self):
            return logoParser.RULE_wipe_clean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWipe_clean" ):
                listener.enterWipe_clean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWipe_clean" ):
                listener.exitWipe_clean(self)




    def wipe_clean(self):

        localctx = logoParser.Wipe_cleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_wipe_clean)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.match(logoParser.WIPE_CLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Clear_screenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLEAR_SCREEN(self):
            return self.getToken(logoParser.CLEAR_SCREEN, 0)

        def getRuleIndex(self):
            return logoParser.RULE_clear_screen

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClear_screen" ):
                listener.enterClear_screen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClear_screen" ):
                listener.exitClear_screen(self)




    def clear_screen(self):

        localctx = logoParser.Clear_screenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_clear_screen)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.match(logoParser.CLEAR_SCREEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





